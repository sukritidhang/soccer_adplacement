# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CYFvWpm-Lfouzx9SRbu8pvzHWZA6BM90
"""

import torch
import torchvision
#from torchvision.models.detection import maskrcnn_resnet50_fpn
from torchvision.transforms import functional as F
from PIL import Image
import matplotlib.pyplot as plt
import cv2
import numpy as np
import os
import scipy
import scipy.sparse
from scipy.sparse.linalg import spsolve
import json

from tqdm import tqdm

class BillboardIntegration:
    def __init__(self, source_path, target_path, device=None):
        #self.source = cv2.imread(source_path, cv2.IMREAD_COLOR)
        src = cv2.imread(source_path, cv2.IMREAD_UNCHANGED)

        if src.shape[2] == 4:  # has alpha
            bgr = src[:, :, :3]
            alpha = src[:, :, 3]

            # Keep as BGR + mask
            self.source = bgr
            self.alpha = alpha
        else:
            self.source = src
            self.alpha = np.ones(self.source.shape[:2], dtype=np.uint8) * 255
        self.target = cv2.imread(target_path, cv2.IMREAD_COLOR)
        self.device = device if device else ("cuda" if torch.cuda.is_available() else "cpu")

        # Load Torchvision Mask R-CNN
        self.model = torchvision.models.detection.maskrcnn_resnet50_fpn(pretrained=True)
        self.model.to(self.device)
        self.model.eval()

    def segment_objects(self, img):
        """
        Returns a binary mask of only 'person' and 'sports ball' objects in the image.
        """
        COCO_PERSON = 1
        COCO_BALL = 37
        TARGET_CLASSES = [COCO_PERSON, COCO_BALL]
        img_tensor = F.to_tensor(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)).to(self.device).unsqueeze(0)

        with torch.no_grad():
            outputs = self.model(img_tensor)

        masks = outputs[0]['masks'].cpu().numpy()  # (N,1,H,W)
        labels = outputs[0]['labels'].cpu().numpy()  # (N,)

        if masks.shape[0] == 0:
            return np.zeros(img.shape[:2], dtype=np.uint8)

        combined_mask = np.zeros(img.shape[:2], dtype=np.uint8)
        for m, l in zip(masks, labels):
            if l in TARGET_CLASSES:
                mask = (m[0] > 0.5).astype(np.uint8) * 255
                combined_mask = cv2.bitwise_or(combined_mask, mask)

        return combined_mask


    def compute_occlusion_error(self, polygon_coords, object_mask=None, extra_mask=None):
      target_h, target_w = self.target.shape[:2]

      # Create polygon mask
      polygon_pts = np.array([[int(p['x'] * target_w), int(p['y'] * target_h)] for p in polygon_coords], dtype=np.int32)
      polygon_mask = np.zeros((target_h, target_w), dtype=np.uint8)
      cv2.fillPoly(polygon_mask, [polygon_pts], 255)

      # Segment objects if needed
      if object_mask is None:
          object_mask = self.segment_objects(self.target)

      if extra_mask is not None:
          extra_mask = cv2.resize(extra_mask, (self.target.shape[1], self.target.shape[0]), interpolation=cv2.INTER_NEAREST)
          _, extra_mask = cv2.threshold(extra_mask, 127, 255, cv2.THRESH_BINARY)
          object_mask = cv2.bitwise_or(object_mask, extra_mask)

      # Calculate intersection
      occluded_mask = cv2.bitwise_and(polygon_mask, object_mask)

      # Calculate error
      total_object_area = np.sum(object_mask > 0)
      occluded_area = np.sum(occluded_mask > 0)

      if total_object_area == 0:
          return 0.0  # No player detected

      return occluded_area / total_object_area

# === Configurable Paths ===

#frames_dir = os.path.expanduser('~/soccernet/soccernet_vd/dataset/Testing3/frames-Testv3')#input frames
frames_dir = os.path.expanduser('~/soccernet/soccernet_vd/output/Testing5/fout-Testv5')#modified frames
#frames_dir = os.path.expanduser('~/soccernet/soccernet_vd/output/Testing3/fout-Testv1wooccl')#without occl frames

polygon_json_dir = os.path.expanduser('~/soccernet/soccernet_vd/dataset/Testing5/json_output_best')
mask_dir = os.path.expanduser('~/soccernet/soccernet_vd/dataset/Testing5/allcoords_masks')


output_video_path = os.path.expanduser('~/soccernet/soccernet_vd/output/Testing5/output_videox.mp4')

source_path = os.path.expanduser('~/soccernet/soccernet_vd/dataset/source/aut-removebg.png')

save_file_path = os.path.expanduser('~/soccernet/soccernet_vd/output/Testing5/')

# Check paths
required_paths = [ polygon_json_dir, frames_dir, source_path, save_file_path]
for path in required_paths:
    if not os.path.exists(path):
        raise FileNotFoundError(f"Required path not found: {path}")

# Prepare frames
frame_files = sorted([f for f in os.listdir(frames_dir) if f.endswith('.jpg')])
if len(frame_files) == 0:
    raise ValueError("No frames found.")

first_frame = cv2.imread(os.path.join(frames_dir, frame_files[0]))
height, width = first_frame.shape[:2]
fps = 25
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
out = cv2.VideoWriter(output_video_path, fourcc, fps, (width, height))

first_frame_path = os.path.join(frames_dir, frame_files[0])
billboard = BillboardIntegration(source_path, first_frame_path)

def reorder_polygon(points):
    pts = [(p['x'], p['y']) for p in points]
    pts_sorted_by_y = sorted(pts, key=lambda p: p[1])
    bottom_two = sorted(pts_sorted_by_y[2:], key=lambda p: p[0])
    bottom_left, bottom_right = bottom_two[0], bottom_two[1]
    top_two = sorted(pts_sorted_by_y[:2], key=lambda p: p[0])
    top_left, top_right = top_two[0], top_two[1]
    return [{'x': x, 'y': y} for x, y in [bottom_left, top_left, top_right, bottom_right]]

occlusion_errors = []

print(f"Processing {len(frame_files)} frames...")
for frame_file in tqdm(frame_files, desc="Processing frames"):
    frame_id_str = frame_file.split("_")[1].split(".")[0]
    frame_path = os.path.join(frames_dir, frame_file)
    frame = cv2.imread(frame_path)

    json_path = os.path.join(polygon_json_dir, f"frame_{frame_id_str}_polygons.json")
    mask_path = os.path.join(mask_dir, f"frame_{frame_id_str}_mask.png")

    frame_processed = False
    if os.path.exists(json_path):
        with open(json_path) as jf:
            data = json.load(jf)

        polygon_coords = data.get("best_polygon", [])
        if len(polygon_coords) >= 4:
            polygon_coords = reorder_polygon(polygon_coords)

            mask_img = None
            if os.path.exists(mask_path):
                mask_img = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
                _, mask_img = cv2.threshold(mask_img, 127, 255, cv2.THRESH_BINARY)

            try:
                billboard.target = frame.copy()
                occ_error = billboard.compute_occlusion_error(polygon_coords, extra_mask=mask_img)
                occlusion_errors.append((frame_id_str, occ_error))
                print(f"Frame {frame_id_str}: Occlusion Error = {occ_error:.4f}")

                #out.write(frame)
                frame_processed = True
            except Exception as e:
                print(f"Warning processing frame {frame_id_str}: {e}")

    #if not frame_processed:
        #out.write(frame)

out.release()

# === Print & Save Results ===
if occlusion_errors:
    avg_error = sum(e[1] for e in occlusion_errors) / len(occlusion_errors)
    print(f"\n‚úÖ Average Occlusion Error over {len(occlusion_errors)} frames: {avg_error:.4f}")

    csv_path = os.path.join(save_file_path, "occlusion_errors.csv")
    with open(csv_path, 'w') as f:
        f.write("frame_id,occlusion_error\n")
        for frame_id, err in occlusion_errors:
            f.write(f"{frame_id},{err:.6f}\n")
    print(f"üìÅ Occlusion error CSV saved to: {csv_path}")
else:
    print("‚ö†Ô∏è No occlusion error data was computed.")

print(f"üé• Output video saved at: {output_video_path}")